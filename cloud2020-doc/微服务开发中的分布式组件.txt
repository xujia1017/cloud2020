0 微服务模块的开发步骤:
    1 建module
    2 改POM
    3 写YML
    4 主启动
    5 业务类


1 服务注册中心
    在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。

    在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者 | 服务提供者），
    以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地 RPC 调用 RPC 远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系 ( 服务治理概念 ) 。
    在任何 rpc 远程框架中，都会有一个注册中心 ( 存放服务地址相关信息 ( 接口地址 ))

    Eureka:
        Eureka 采用了 CS 的设计架构， Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server 并维持心跳连接。
        这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。
        Eureka Server: 提供服务注册服务
            各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。

        Eureka Client: 通过注册中心进行访问
            是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。
            如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除（默认90秒）.

    consul:
        Consul 是一套开源的分布式服务发现和配置管理系统。
        提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，
        总之Consul提供了一种完整的服务网格解决方案。

    Zookeeper:
        Zookeeper是一个分布式协调工具，可以实现注册中心功能。

    Nacos:

    对比:
        1 Eureka是CP，Zookeeper和Consul是AP，


2 负载均衡
      LB负载均衡(Load Balance)是什么:
            简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。 常见的负载均衡有软件Nginx，LVS，硬件 F5等。

      RestTemplate:
            Spring提供的一个访问 Http 服务的客户端类

      Ribbon: 是运行在消费者端（客户端）的负载均衡器
            主要功能是提供 客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时、重试等。
            简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。
            我们很容易使用Ribbon实现自定义的负载均衡算法。

            Ribbon在工作时分成两步
                第一步先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server.
                第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。

      Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别
            Nginx是服务器端负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。
            Ribbon本地(客户端)负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。


3 服务调用
      Feign:
            Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端。Feign旨在使编写Java Http客户端变得更容易，更优雅。
            它的使用方法是 定义一个服务接口然后在上面添加注解即可。

            前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，
            所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。 所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。
            在Feign的实现下， 我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可) ，
            即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。

            Feign集成了Ribbon, 利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。

      OpenFeign:
            OpenFeign是Spring Cloud 在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。
            OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。

            也是运行在消费者端的，使用 Ribbon 进行负载均衡，所以 OpenFeign 直接内置了 Ribbon

            所谓的OpenFeign，就是客户端服务接口根据@FeignClient注解value值所指向的"微服务名称"去调用服务侧我们暴露对外提供的方法。


4 服务降级/熔断
    降级: 降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的恢复。
         比如Hystrix的后背处理模式，通过设置fallbackMethod来给一个方法设置备用的代码逻辑。
    熔断: 熔断是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 断路器 直接将此请求链路断开。
         当检测到该节点微服务调用响应正常后，恢复调用链路。
         比如通过 @HystrixCommand 注解来标注某个方法，这样 Hystrix 就会使用 断路器 来“包装”这个方法，每当调用时间超过指定时间时(默认为 1000ms)，断路器将会中断对这个方法的调用。

    Hystrix:
        1 就是一个能进行`熔断` 和`降级`的库，通过使用它能提高整个分布式系统的弹性。
        2 在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix 是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。
          Hystrix 通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。

    Sentinel:
        1
        2



5 服务网关
    网关: 网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行鉴权、限流、 路由、监控等功能。
         API网关为微服务架构中的服务提供了统一的访问入口，客户端通过API网关访问相关服务。
         API网关的定义类似于设计模式中的门面模式，它相当于整个微服务架构中的门面，所有客户端的访问都通过它来进行路由及过滤。
         它实现了请求路由、负载均衡、校验过滤、服务容错、服务聚合等功能

    网关和Nginx:
        https://www.jianshu.com/p/8d82c6c2e5ee
        https://blog.csdn.net/awodwde/article/details/113856091
        https://blog.csdn.net/Aizen_Sousuke/article/details/106640778

        API网关与Nginx的区别:
            api网关与nginx的区别还是比较明显的。
            Nginx是内核和模块组成的。内核设计的比较简单，功能是通过查找客户端以及匹配URL，然后再来启动不同模块下的功能作用。
            其次是nginx的编译模式是静态编译模式，静态编译模式和api网关的模式有所不同。
            并且在处理请求的时候 Nginx每次只能处理一个请求，处理请求的方式是异步非阻塞的方式。

        API网关的优点:
            首先是系统易于监控，可以从网络端口来收集信息从而进行有效分析。
            其次是方便于身份认证，只需在api网关上进行认证，就可以直达不同的微服务系统。
            还有一点是可以减少客户端与各种服务端的交互验证次数，让用户可以一次认证，从而最快进入到不同的微服务架构当中。

    Nigx和Gateway的区别:
        1 Nigx是 用户 到 前端工程 的 对外网关
        2 Gateway是 前端工程 到 后端服务 之间的一个 对外网关

    微服务架构中网关在哪里:
        外部请求 -> 负载均衡 -> 网关 -> 微服务

    Zuul:
        1 Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。是Netflix出品的一个基于JVM路由和服务端的负载均衡器。
        2

    Spring Cloud GateWay:
        1 Gateway 是在Spring生态系统之上构建的API网关服务，基于 Spring5 ， SpringBoot2 和 Project Reactor 等技术。
        2 Gateway 旨在提供统一的路由方式且基于 Filter 链的方式提供了网关基本的功能， 例如：熔断、限流、重试等。
        3 具有如下:
            动态路由：能够匹配任何请求属性；
            可以对路由指定 Predicate（断言）和 Filter（过滤器）；
            集成Hystrix的断路器功能；
            集成 Spring Cloud服务发现功能；
            易于编写的 Predicate（断言）和 Filter（过滤器）；
            请求限流功能；
            支持路径重写。


6 分布式配置中心
    SpringCloud config:
        1 SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为 各个不同微服务应用 的所有环境提供了一个 中心化的外部配置 。
        2 SpringCloud Config 分为 服务端和客户端两部分:
            服务端也称为-分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口
            客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。
            配置服务器默认采用 git 来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过 git 客户端工具来方便的管理和访问配置内容。

            简单说，就是能将各个 应用/系统/模块 的配置文件存放到统一的地方然后进行管理(Git 或者 SVN)。
        3 能干嘛:
            集中管理配置文件
            不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release
            运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉去自己的信息
            当配置发生变动时，服务不需要重启饥渴感知到配置的变化，并应用新的配置
            将配置信息以REST接口的形式暴露
            SpringCloud Config默认使用Git来存储配置文件
    nacos


7 消息总线
    什么是总线
        在微服务架构的系统中，通常会使用`轻量级的消息代理`来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。
        由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。
        在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。

    SpringCloud Bus:
        1 用于将服务和服务实例与分布式消息系统链接在一起的事件总线。它整合了Java的事件处理机制和消息中间件的功能。
          在集群中传播状态更改很有用（例如配置更改事件）。SpringCloud Bus目前支持RabbitMQ和Kafka。

        2 SpringCloud Bus能管理和广播分布式系统中的消息，就像一个分布式执行器，可用于广播状态更改，事件推送等，也可以当做微服务间的通信通道。
          当然作为`消息总线`的SpringCloud Bus可以做很多事而不仅仅是客户端的配置刷新功能。

        3 拥有了SpringCloud Bus之后，我们只需要创建一个简单的请求，并且加上 @ResfreshScope 注解就能进行配置的动态修改了

        4 ConfigClient实例都监听MQ中同一个topic(默认是springCloudBus)。
          当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。


8 分布式消息及驱动
    消息驱动:
        屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。

    SpringCloud Stream:
        当我们的系统和底层的消息中间件耦合在一起的时候，SpringCloud Stream给我们提供了一种解耦合的方式。
        通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。
        通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离 。Stream对消息中间件的进一步封装，
        可以做到代码层面对中间件的无感知，甚至于动态的切换中间件(rabbitmq切换为kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务流程。


    Rabbit MQ
    Rocket MQ
    kafka



9 分布式请求链路跟踪
    Java 线上诊断工具 Arthas
    数据处理工具 EasyExcel
    数据库连接池 Druid
    链路追踪Tracing Analysis

    SpringCloud Sleuth提供了一套完整的服务追踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin

10 Nacos: Dynamic Naming and Configuration Service
    Nacos就是`注册中心`+`配置中心`，等价于 Nacos = Eureka + Config + Bus
    能干嘛:
        替代Eureka做服务注册中心
        替代Config做服务注册中心



11 熔断与限流SpringCloud Alibaba Sentinel(Hytrix):
    Sentinel是什么:
        随着微服务的流行，服务和服务之间的稳定性变得越来越重要。
        Sentinel以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。

    Sentinel 具有以下特征:
        丰富的应用场景：Sentinel承接了阿里巴巴近10年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。
        完备的实时监控：Sentinel同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至500台以下规模的集群的汇总运行情况。
        广泛的开源生态：Sentinel提供开箱即用的与其它开源框架/库的整合模块，例如与Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。同时Sentinel提供Java/Go/C++ 等多语言的原生实现。
        完善的SPI扩展机制：Sentinel提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。



12 分布式事务
    Seata









服务限流降级 ：默认支持 Servlet 、 Feign 、 RestTemplate 、 Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。
服务注册与发现 ：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。
分布式配置管理 ：支持分布式系统中的外部化配置，配置更改时自动刷新。
消息驱动能力 ：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。
阿里云对象存储 ：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。
分布式任务调度 ：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker （ schedulerx-client ）上执行。













状态机模型中的4个要素，即现态、条件、动作、次态。

现态：是指当前所处的状态。
条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。
动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。
次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。

大白话：
    现态在什么条件下，触发了什么动作，产生了什么次态































